<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Truth Engine Mobile</title>
<style>
body{font-family:Arial,sans-serif;margin:12px;max-width:980px}
h1{font-size:18px;margin:0 0 8px 0}
.small{font-size:12px;color:#444}
.row{display:flex;flex-direction:column;gap:12px;margin-top:12px}
.card{border:1px solid #d0d0d0;border-radius:14px;padding:12px;background:#fff}
label{display:block;margin:10px 0 6px;font-weight:700;font-size:13px}
input[type=text],textarea,select{width:100%;box-sizing:border-box;padding:10px;border:1px solid #bdbdbd;border-radius:12
textarea{min-height:70px;resize:vertical}
button{padding:10px 12px;border:1px solid #444;border-radius:14px;background:#fff;cursor:pointer;font-size:14px}
button:disabled{opacity:.5;cursor:not-allowed}
.btnrow{display:flex;gap:8px;flex-wrap:wrap}
.pill{display:inline-block;padding:3px 10px;border-radius:999px;border:1px solid #aaa;font-size:12px;margin-right:6px}
.mono{font-family:ui-monospace,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px}
.muted{color:#666}
.item{margin:10px 0;padding:10px;border:1px solid #ddd;border-radius:14px}
.itemHead{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.boxGood{background:#f1fff3;border:1px solid #c8e6c9;padding:10px;border-radius:14px}
.boxWarn{background:#fff8e1;border:1px solid #ffe0b2;padding:10px;border-radius:14px}
.boxBad{background:#fff5f5;border:1px solid #ffcdd2;padding:10px;border-radius:14px}
.tiny{font-size:11px;color:#555}
canvas{width:100%;height:auto;border-radius:12px;background:#fafafa;touch-action:none}
video{width:100%;height:auto;border-radius:12px;background:#000}
.grid2{display:grid;grid-template-columns:1fr;gap:10px}
@media (min-width:860px){ .row{flex-direction:row;align-items:flex-start} .left{flex:1.15} .right{flex:.85} .grid2{grid-
</style>
</head>
<body>
<h1>Truth Engine Mobile</h1>
<div class="small">Local only. No network calls. Assist drafts never become truth until you approve.</div>
<div class="row">
<div class="card left">
<div class="itemHead">
<div>
<span class="pill">Signal</span>
<span class="pill">Viewer</span>
<span class="pill">Assist</span>
</div>
<div class="btnrow">
<button id="importBtn">Import JSON</button>
<button id="exportBtn">Export JSON</button>
<button id="resetBtn">Reset</button>
</div>
</div>
<label>Case name</label>
<input id="caseName" type="text" placeholder="Example: Curtain test 01"/>
<div class="grid2">
<div>
<label>Scope</label>
<select id="scopeTag">
<option value="personal">personal</option>
<option value="private">private</option>
<option value="shareable">shareable</option>
</select>
</div>
<div>
<label>Signal time</label>
<input id="sigTime" type="text" readonly class="mono"/>
</div>
</div>
<label>Curiosity question</label>
<textarea id="kidQ" placeholder="What do you want to learn from this scene"></textarea>
<label>Signal quality notes</label>
<textarea id="sigNotes" placeholder="Occlusion, blur, glare, reflections, distance"></textarea><label>Upload image</label>
<input id="imgInput" type="file" accept="image/*"/>
<label>Live camera</label>
<div class="btnrow">
<button id="startCamBtn">Start camera</button>
<button id="stopCamBtn" disabled>Stop camera</button>
<button id="captureBtn" disabled>Capture frame</button>
</div>
<div id="camMsg" class="tiny muted"></div>
<video id="camView" autoplay playsinline style="display:none"></video>
<div class="item" style="margin-top:10px">
<div class="itemHead">
<div>
<span class="pill">Toggles</span>
<span class="pill mono" id="viewerStatus">no signal</span>
</div>
<div class="btnrow">
<button id="fitBtn" disabled>Fit</button>
<button id="clearSelBtn" disabled>Clear selection</button>
</div>
</div>
<div class="btnrow" style="margin:8px 0">
<label class="tiny"><input id="edgeToggle" type="checkbox"/> edges</label>
<label class="tiny"><input id="anchorToggle" type="checkbox" checked/> evidence anchors</label>
</div>
<label class="tiny">Zoom</label>
<input id="zoomRange" type="range" min="10" max="400" value="100" disabled/>
<canvas id="viewCanvas" width="720" height="520"></canvas>
<canvas id="workCanvas" width="720" height="520" style="display:none"></canvas><div id="regionBox" style="margin-top:10px"></div>
</div>
<div class="itemHead">
<div>
<span class="pill">Assist Mode</span>
<span class="pill">Drafts only</span>
</div>
<div class="btnrow">
<button id="assistBtn" disabled>Generate drafts</button>
<button id="clearDraftsBtn" disabled>Clear drafts</button>
</div>
</div>
<div class="tiny muted">Drafts use measurable signal features. You must approve every claim.</div>
<div id="draftsBox"></div>
<label>Global assumptions</label>
<textarea id="assumptionsGlobal" placeholder="Assumptions about the scene"></textarea>
<label>Global constraints</label>
<textarea id="constraintsGlobal" placeholder="Physics limits, sensor limits, privacy limits"></textarea>
<div id="auditBox" style="margin-top:10px"></div>
</div>
<div class="card right">
<div class="itemHead">
<div>
<span class="pill">Truth panels</span>
<span class="pill">Governed</span>
</div>
<div class="btnrow">
<button id="runChecksBtn">Run checks</button>
</div>
</div>
<label>Panel</label>
<select id="kind">
<option value="Observed">Observed</option>
<option value="Inferred">Inferred</option>
<option value="Unknown">Unknown</option>
<option value="Path">Path</option>
</select>
<label>Claim text</label>
<textarea id="text"></textarea>
<label>Evidence pointer</label>
<textarea id="evidence" placeholder="Selection coords or region notes"></textarea>
<div class="grid2">
<div>
<label>Because</label>
<textarea id="because" placeholder="Required for Inferred"></textarea>
</div>
<div>
<label>Missing signal</label>
<textarea id="missing" placeholder="Required for Unknown"></textarea>
</div>
</div>
<label>Contradiction</label>
<textarea id="contradiction" placeholder="What would disprove this"></textarea>
<label>Assumptions for this claim</label>
<textarea id="assumptionsLocal"></textarea>
<div class="grid2">
<div>
<label>Confidence</label>
<input id="conf" type="range" min="0" max="100" value="70"/>
<div class="tiny muted">Confidence: <span id="confVal">0.70</span></div>
</div>
<div>
<label>Risk</label>
<select id="risk">
<option value="low">low</option>
<option value="medium">medium</option>
<option value="high">high</option>
</select>
</div>
</div><div class="btnrow" style="margin-top:10px">
<button id="addBtn">Add</button>
<button id="calibrateBtn">Calibration log</button>
</div>
<div id="checks" style="margin-top:10px"></div>
<div id="calibration" style="margin-top:10px"></div>
<div class="itemHead" style="margin-top:10px">
<div><span class="pill" style="border-color:#2e7d32;color:#2e7d32">Observed</span></div>
<button onclick="clearPanel('Observed')">Clear</button>
</div>
<div id="ObservedList"></div>
<div class="itemHead" style="margin-top:10px">
<div><span class="pill" style="border-color:#ef6c00;color:#ef6c00">Inferred</span></div>
<button onclick="clearPanel('Inferred')">Clear</button>
</div>
<div id="InferredList"></div>
<div class="itemHead" style="margin-top:10px">
<div><span class="pill" style="border-color:#c62828;color:#c62828">Unknown</span></div>
<button onclick="clearPanel('Unknown')">Clear</button>
</div>
<div id="UnknownList"></div><div class="itemHead" style="margin-top:10px">
<div><span class="pill">Paths</span></div>
<button onclick="clearPanel('Path')">Clear</button>
</div>
<div id="PathList"></div>
</div>
</div>
<script>
(() => {
const state = {
signal: { loaded:false, w:0, h:0, timestamp:null, source:"none" },
panels: { Observed:[], Inferred:[], Unknown:[], Path:[] },
drafts: [],
calibration: [],
selection: null,
anchors: {}, // claimId -> rect
cam: { stream:null, active:false },
view: { zoom:1, panX:0, panY:0, dragging:false, lastX:0, lastY:0, selecting:false, pressTimer:null, selStart:null }
};
const $ = id => document.getElementById(id);
const viewCanvas = $("viewCanvas");
const vctx = viewCanvas.getContext("2d");
const workCanvas = $("workCanvas");
const wctx = workCanvas.getContext("2d");
const camView = $("camView");
const camMsg = $("camMsg");
const img = new Image();
img.crossOrigin = "anonymous";
function nowIso(){ return new Date().toISOString(); }
function esc(s){ return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }
const conf = $("conf");
const confVal = $("confVal");
conf.addEventListener("input", ()=> confVal.textContent = (Number(conf.value)/100).toFixed(2));
conf.dispatchEvent(new Event("input"));
function setSigTime(){
$("sigTime").value = state.signal.timestamp || "";
$("viewerStatus").textContent = state.signal.loaded ? ("signal " + state.signal.source) : "no signal";
}
function enableSignalUI(on){
$("fitBtn").disabled = !on;
$("clearSelBtn").disabled = !on;
$("zoomRange").disabled = !on;
$("assistBtn").disabled = !on;
$("clearDraftsBtn").disabled = !on;
}
function loadImage(src, source){
img.onload = () => {
state.signal.loaded = true;
state.signal.w = img.naturalWidth || img.width;
state.signal.h = img.naturalHeight || img.height;
state.signal.timestamp = nowIso();
state.signal.source = source || "upload";
state.selection = null;
setSigTime();
enableSignalUI(true);
fit();
renderAll();
runChecks();
renderAudit();
};
img.src = src;
}
$("imgInput").addEventListener("change", (e) => {
const f = e.target.files && e.target.files[0];
if(!f) return;
loadImage(URL.createObjectURL(f), "upload");
stopCamera();
});
function secureContextHint(){
if (window.isSecureContext) return "";
return "Camera may require https or localhost on your device.";
}
async function startCamera(){camMsg.textContent = secureContextHint();
try{
const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: "environment" } }, audio:fals
state.cam.stream = stream;
state.cam.active = true;
camView.srcObject = stream;
camView.style.display = "block";
$("startCamBtn").disabled = true;
$("stopCamBtn").disabled = false;
$("captureBtn").disabled = false;
camMsg.textContent = "Camera active. Capture a frame to load it into the engine.";
}catch(err){
camMsg.textContent = "Camera error: " + err.message + " " + secureContextHint();
alert(camMsg.textContent);
}
}
function stopCamera(){
if(state.cam.stream){
state.cam.stream.getTracks().forEach(t=>t.stop());
}
state.cam.stream = null;
state.cam.active = false;
camView.style.display = "none";
$("startCamBtn").disabled = false;
$("stopCamBtn").disabled = true;
$("captureBtn").disabled = true;}
function captureFrame(){
if(!state.cam.active || !camView.videoWidth) return;
workCanvas.width = camView.videoWidth;
workCanvas.height = camView.videoHeight;
wctx.drawImage(camView,0,0);
const dataUrl = workCanvas.toDataURL("image/png");
loadImage(dataUrl, "camera");
stopCamera();
}
$("startCamBtn").addEventListener("click", startCamera);
$("stopCamBtn").addEventListener("click", stopCamera);
$("captureBtn").addEventListener("click", captureFrame);
// Viewer render
function fit(){
if(!state.signal.loaded) return;
const cw = viewCanvas.width, ch = viewCanvas.height;
const iw = state.signal.w, ih = state.signal.h;
const s = Math.min(cw/iw, ch/ih);
state.view.zoom = s;
$("zoomRange").value = Math.max(10, Math.min(400, Math.round(s*100)));
state.view.panX = (cw - iw*s)/2;
state.view.panY = (ch - ih*s)/2;
}
$("fitBtn").addEventListener("click", ()=>{ fit(); renderAll(); });
$("zoomRange").addEventListener("input", ()=>{
state.view.zoom = Number($("zoomRange").value)/100;
renderAll();
});
function canvasToImage(cx, cy){
const z = state.view.zoom;
return { x:(cx - state.view.panX)/z, y:(cy - state.view.panY)/z };
}
function clampRect(r){
const x = Math.max(0, Math.min(state.signal.w, r.x));
const y = Math.max(0, Math.min(state.signal.h, r.y));
const w = Math.max(0, Math.min(state.signal.w - x, r.w));
const h = Math.max(0, Math.min(state.signal.h - y, r.h));
return { x, y, w, h };
}
function beginSelectAt(cx, cy){
const p = canvasToImage(cx, cy);
state.view.selecting = true;
state.view.selStart = { x:p.x, y:p.y };
state.selection = { x:p.x, y:p.y, w:0, h:0 };
}
function updateSelectTo(cx, cy){
const p = canvasToImage(cx, cy);
const sx = state.view.selStart.x, sy = state.view.selStart.y;
const x = Math.min(sx, p.x), y = Math.min(sy, p.y);
const w = Math.abs(p.x - sx), h = Math.abs(p.y - sy);
state.selection = clampRect({ x, y, w, h });
function clearPressTimer(){
if(state.view.pressTimer){ clearTimeout(state.view.pressTimer); state.view.pressTimer = null; }
}
}
viewCanvas.addEventListener("pointerdown", (ev)=>{
if(!state.signal.loaded) return;
ev.preventDefault();
const r = viewCanvas.getBoundingClientRect();
const cx = ev.clientX - r.left, cy = ev.clientY - r.top;
state.view.dragging = true;
state.view.lastX = cx; state.view.lastY = cy;
state.view.selecting = false;
state.view.selStart = null;
clearPressTimer();
state.view.pressTimer = setTimeout(()=>{ beginSelectAt(cx, cy); renderAll(); renderRegion(); }, 320);
});
viewCanvas.addEventListener("pointermove", (ev)=>{if(!state.signal.loaded || !state.view.dragging) return;
ev.preventDefault();
const r = viewCanvas.getBoundingClientRect();
const cx = ev.clientX - r.left, cy = ev.clientY - r.top;
if(state.view.selecting && state.view.selStart){
updateSelectTo(cx, cy);
renderAll(); renderRegion();
return;
}
clearPressTimer();
const dx = cx - state.view.lastX, dy = cy - state.view.lastY;
state.view.lastX = cx; state.view.lastY = cy;
state.view.panX += dx; state.view.panY += dy;
renderAll(); renderRegion();
});
function endDrag(ev){
if(!state.signal.loaded) return;
ev.preventDefault();
clearPressTimer();
state.view.dragging = false;
state.view.selecting = false;
state.view.selStart = null;
renderAll(); renderRegion();
}viewCanvas.addEventListener("pointerup", endDrag);
viewCanvas.addEventListener("pointercancel", endDrag);
$("clearSelBtn").addEventListener("click", ()=>{
state.selection = null;
renderAll(); renderRegion();
});
function drawImage(){
vctx.clearRect(0,0,viewCanvas.width,viewCanvas.height);
if(!state.signal.loaded){
vctx.fillStyle = "#666";
vctx.font = "14px Arial";
vctx.fillText("Load an image or capture a frame.", 16, 28);
return;
}
const z = state.view.zoom;
vctx.save();
vctx.translate(state.view.panX, state.view.panY);
vctx.scale(z, z);
vctx.drawImage(img, 0, 0);
vctx.restore();
}
function edgeOverlay(){
// Fast overlay computed on a downscaled copy; then drawn scaled on viewer.
const iw = state.signal.w, ih = state.signal.h;
const maxDim = 640;
const s = Math.min(1, maxDim / Math.max(iw, ih));
const w = Math.max(1, Math.floor(iw*s));
const h = Math.max(1, Math.floor(ih*s));
const c = document.createElement("canvas");
c.width = w; c.height = h;
const ctx = c.getContext("2d");
ctx.drawImage(img,0,0,w,h);
const id = ctx.getImageData(0,0,w,h);
const d = id.data;
const lum = new Float32Array(w*h);
for(let i=0,p=0;i<w*h;i++,p+=4){
lum[i] = 0.2126*d[p] + 0.7152*d[p+1] + 0.0722*d[p+2];
}
const out = ctx.createImageData(w,h);
const o = out.data;
for(let y=1;y<h-1;y++){
for(let x=1;x<w-1;x++){
const i = y*w+x;
const gx = (lum[i+1]-lum[i-1]) + 2*(lum[i+1+w]-lum[i-1+w]) + (lum[i+1-w]-lum[i-1-w]);
const gy = (lum[i+w]-lum[i-w]) + 2*(lum[i+w+1]-lum[i-w+1]) + (lum[i+w-1]-lum[i-w-1]);
const mag = Math.min(255, Math.abs(gx) + Math.abs(gy));
const p = i*4;
o[p] = 255; o[p+1] = 255; o[p+2] = 255; o[p+3] = mag > 140 ? 180 : 0;
}
}
ctx.putImageData(out,0,0);
// draw overlay aligned with viewer
const z = state.view.zoom;
vctx.save();
vctx.translate(state.view.panX, state.view.panY);
vctx.scale(z, z);
vctx.globalAlpha = 0.9;
vctx.drawImage(c, 0, 0, iw, ih);
vctx.globalAlpha = 1;
vctx.restore();
}
function drawSelection(){
if(!state.selection) return;
const z = state.view.zoom;
vctx.save();
vctx.strokeStyle = "#1976d2";
vctx.lineWidth = 2;
vctx.setLineDash([6,4]);
vctx.strokeRect(
state.view.panX + state.selection.x*z,
state.view.panY + state.selection.y*z,
state.selection.w*z,
state.selection.h*z
);
vctx.setLineDash([]);
vctx.restore();}
function drawAnchors(){
if(!$("anchorToggle").checked) return;
const z = state.view.zoom;
vctx.save();
vctx.strokeStyle = "#8e24aa";
vctx.lineWidth = 2;
for(const id in state.anchors){
const r = state.anchors[id];
vctx.strokeRect(
state.view.panX + r.x*z,
state.view.panY + r.y*z,
r.w*z,
r.h*z
}
);
vctx.restore();
}
function renderAll(){
drawImage();
if(state.signal.loaded && $("edgeToggle").checked) edgeOverlay();
if(state.signal.loaded) drawAnchors();
if(state.signal.loaded) drawSelection();
renderRegion();
renderDrafts();
renderPanels();setSigTime();
}
// Region metrics
function regionStats(rect){
const x = Math.max(0, Math.floor(rect.x));
const y = Math.max(0, Math.floor(rect.y));
const w = Math.max(1, Math.floor(rect.w));
const h = Math.max(1, Math.floor(rect.h));
const maxPix = 900*900;
// Downscale large selection to keep it fast on mobile
let rw = w, rh = h, scale = 1;
if(w*h > maxPix){
scale = Math.sqrt(maxPix / (w*h));
rw = Math.max(1, Math.floor(w*scale));
rh = Math.max(1, Math.floor(h*scale));
}
const c = workCanvas;
c.width = rw; c.height = rh;
wctx.drawImage(img, x, y, w, h, 0, 0, rw, rh);
const id = wctx.getImageData(0,0,rw,rh);
const d = id.data;
let sum=0,sum2=0,min=255,max=0;
let edges=0;
const lum = new Float32Array(rw*rh);
for(let i=0,p=0;i<rw*rh;i++,p+=4){
const L = 0.2126*d[p] + 0.7152*d[p+1] + 0.0722*d[p+2];
lum[i]=L;
sum+=L; sum2+=L*L;
if(L<min) min=L;
if(L>max) max=L;
}
const mean = sum/(rw*rh);
const variance = Math.max(0,(sum2/(rw*rh))-mean*mean);
const std = Math.sqrt(variance);
for(let yy=1; yy<rh-1; yy++){
for(let xx=1; xx<rw-1; xx++){
const i = yy*rw+xx;
const gx = (lum[i+1]-lum[i-1]) + (lum[i+1+rw]-lum[i-1+rw]) + (lum[i+1-rw]-lum[i-1-rw]);
const gy = (lum[i+rw]-lum[i-rw]) + (lum[i+rw+1]-lum[i-rw+1]) + (lum[i+rw-1]-lum[i-rw-1]);
const mag = Math.abs(gx)+Math.abs(gy);
if(mag > 80) edges++;
}
}
const edgeDensity = edges / Math.max(1,(rw-2)*(rh-2));
return { mean, std, min, max, edgeDensity, sampleW:rw, sampleH:rh, scale };
}
function renderRegion(){
const box = $("regionBox");
if(!state.signal.loaded){
box.innerHTML = `<div class="tiny muted">No signal loaded.</div>`;
return;
}
const rect = state.selection || { x:0, y:0, w:state.signal.w, h:state.signal.h };
const s = regionStats(rect);
const selText = state.selection
? `selection x:${rect.x.toFixed(1)} y:${rect.y.toFixed(1)} w:${rect.w.toFixed(1)} h:${rect.h.toFixed(1)}`
: "full image";
box.innerHTML = `
<div class="boxGood">
<div class="tiny"><span class="k">Region</span>: ${esc(selText)}</div>
<div class="tiny"><span class="k">Brightness mean</span>: ${s.mean.toFixed(1)} <span class="k">std</span>: ${s.std.t
<div class="tiny"><span class="k">Edge density</span>: ${s.edgeDensity.toFixed(4)} <span class="muted">(higher often
<div class="tiny muted">Tip: long press then drag to select a region. Evidence pointer can reference these numbers.<
</div>
`;
}
// Assist drafts
function makeDrafts(){
const rect = state.selection || { x:0, y:0, w:state.signal.w, h:state.signal.h };
const s = regionStats(rect);
const regionRef = state.selection ? "selection" : "full image";
const drafts = [];
drafts.push({
kind:"Observed",
text:`Region brightness mean is about ${s.mean.toFixed(1)} on a 0 to 255 scale.`,
evidence:`assist metrics for ${regionRef}: mean ${s.mean.toFixed(1)}, std ${s.std.toFixed(1)}`,because:"",
missing:"",
contradiction:"If exposure was heavily altered, brightness stats may not represent scene lighting.",
assumptions:"Pixel luminance correlates with scene exposure.",
confidence:0.70,
risk:"low",
anchor: state.selection ? { ...state.selection } : null
});
drafts.push({
kind:"Observed",
text:`Region edge density is about ${s.edgeDensity.toFixed(4)} indicating ${s.edgeDensity>0.01 ? "noticeable structure
evidence:`assist metrics for ${regionRef}: edge density ${s.edgeDensity.toFixed(4)}`,
because:"",
missing:"A closer view or multiple frames could confirm whether edges are real boundaries or artifacts.",
contradiction:"Compression artifacts or noise can create false edges.",
assumptions:"Edge density correlates with visible boundaries.",
confidence:0.62,
risk:"low",
anchor: state.selection ? { ...state.selection } : null
});
drafts.push({
kind:"Inferred",
text:"A bright structured region could be a reflective surface or a framed opening, but this is a hypothesis.",
evidence:`assist: higher brightness and edges in ${regionRef}`,
because:"Bright plus structured patterns sometimes match glass or frames, but multiple other explanations exist.",
missing:"A new angle or a second image with different lighting to test the hypothesis.",contradiction:"If edges do not form stable straight boundaries across views, the frame hypothesis weakens.",
assumptions:"Structured bright regions can indicate framed or reflective surfaces.",
confidence:0.45,
risk:"low",
anchor: state.selection ? { ...state.selection } : null
});
drafts.push({
kind:"Unknown",
text:"Details fully hidden by occlusion cannot be determined from this single signal.",
evidence:"information is absent where the signal is blocked",
because:"",
missing:"A new viewpoint, moving the occluder, or a different sensing modality.",
contradiction:"If a new signal reveals the hidden area, this becomes known.",
assumptions:"Occlusion blocks information flow.",
confidence:0.90,
risk:"low",
anchor:null
});
drafts.push({
kind:"Path",
text:"Path: capture a second image from a different angle and compare changes to reduce ambiguity.",
evidence:"multi view reduces occlusion uncertainty",
because:"Changing viewpoint can reveal boundaries and invalidate false interpretations.",
missing:"",
contradiction:"If you cannot capture a second view, this path is unavailable.",
assumptions:"You can provide another signal.",
confidence:0.70,
risk:"low",
anchor:null
});
return drafts;
}
function renderDrafts(){
const box = $("draftsBox");
if(!state.signal.loaded){
box.innerHTML = `<div class="tiny muted">Load a signal to enable drafts.</div>`;
return;
}
if(state.drafts.length===0){
box.innerHTML = `<div class="tiny muted">No drafts yet.</div>`;
return;
}
box.innerHTML = state.drafts.map((d, idx)=>`
<div class="item">
<div class="itemHead">
<div>
<span class="pill">${esc(d.kind)} draft</span>
<span class="pill mono">${d.confidence.toFixed(2)}</span>
<span class="pill">${esc(d.risk)}</span>
</div>
<div class="btnrow">
<button onclick="prefillDraft(${idx})">Prefill</button>
<button onclick="approveDraft(${idx})">Approve</button>
</div>
</div>
<div>${esc(d.text)}</div>
<div class="tiny"><span class="k">evidence</span>: ${esc(d.evidence)}</div>
${d.because ? `<div class="tiny"><span class="k">because</span>: ${esc(d.because)}</div>` : ``}
${d.missing ? `<div class="tiny"><span class="k">missing</span>: ${esc(d.missing)}</div>` : ``}
${d.contradiction ? `<div class="tiny"><span class="k">contradiction</span>: ${esc(d.contradiction)}</div>` : ``}
${d.assumptions ? `<div class="tiny"><span class="k">assumptions</span>: ${esc(d.assumptions)}</div>` : ``}
<div class="tiny muted">Draft is not valid until approved.</div>
</div>
`).join("");
}
$("assistBtn").addEventListener("click", ()=>{
state.drafts = makeDrafts();
renderDrafts();
});
$("clearDraftsBtn").addEventListener("click", ()=>{
state.drafts = [];
renderDrafts();
});
window.prefillDraft = (idx)=>{
const d = state.drafts[idx];if(!d) return;
$("kind").value = d.kind;
$("text").value = d.text;
$("evidence").value = d.evidence;
$("because").value = d.because || "";
$("missing").value = d.missing || "";
$("contradiction").value = d.contradiction || "";
$("assumptionsLocal").value = d.assumptions || "";
conf.value = Math.round(d.confidence*100);
conf.dispatchEvent(new Event("input"));
$("risk").value = d.risk || "low";
// also set selection if draft includes anchor
if(d.anchor){
state.selection = { ...d.anchor };
renderAll();
}
};
function bannedInObserved(text){
const t = (text||"").toLowerCase();
const banned = ["maybe","likely","probably","could be","might be","i think","i guess","suggests"];
return banned.some(w=>t.includes(w));
}
window.approveDraft = (idx)=>{
const d = state.drafts[idx];
if(!d) return;// Governance gates
if(d.kind==="Observed"){
if(!d.evidence) return alert("Observed needs evidence pointer.");
if(bannedInObserved(d.text)) return alert("Observed cannot contain inference language.");
}
if(d.kind==="Inferred" && (!d.because || d.because.length<3)) return alert("Inferred needs because.");
if(d.kind==="Unknown" && (!d.missing || d.missing.length<3)) return alert("Unknown needs missing signal.");
// Approve
const claimId = crypto.randomUUID();
state.panels[d.kind].push({
id: claimId,
kind: d.kind,
text: d.text,
evidence: d.evidence,
because: d.because || "",
missing: d.missing || "",
contradiction: d.contradiction || "",
assumptions: d.assumptions || "",
confidence: d.confidence,
risk: d.risk,
source: "assist approved",
at: nowIso()
});
if(d.anchor){
state.anchors[claimId] = { ...d.anchor };
}
renderPanels();
renderAll();
runChecks();
renderAudit();
};
// Manual add
$("addBtn").addEventListener("click", ()=>{
const kind = $("kind").value;
const text = $("text").value.trim();
if(!text) return alert("Write claim text.");
if(kind==="Observed" && bannedInObserved(text)) return alert("Observed cannot contain inference language.");
if(kind==="Inferred" && $("because").value.trim().length<3) return alert("Inferred needs because.");
if(kind==="Unknown" && $("missing").value.trim().length<3) return alert("Unknown needs missing signal.");
const claimId = crypto.randomUUID();
state.panels[kind].push({
id: claimId,
kind,
text,
evidence: $("evidence").value.trim(),
because: $("because").value.trim(),
missing: $("missing").value.trim(),
contradiction: $("contradiction").value.trim(),
assumptions: $("assumptionsLocal").value.trim(),
confidence: Number(conf.value)/100,
risk: $("risk").value,
source: "manual",
at: nowIso()
});
if(state.selection){
state.anchors[claimId] = { ...state.selection };
}
$("text").value=""; $("evidence").value=""; $("because").value=""; $("missing").value="";
$("contradiction").value=""; $("assumptionsLocal").value="";
renderPanels();
renderAll();
runChecks();
renderAudit();
});
window.clearPanel = (kind)=>{
state.panels[kind] = [];
// remove anchors belonging to that panel
const keep = {};
for(const k in state.anchors){
const found = Object.values(state.panels).flat().find(x=>x.id===k);
if(found) keep[k]=state.anchors[k];
}
state.anchors = keep;
renderPanels(); renderAll(); runChecks(); renderAudit();
};
window.removeClaim = (kind, id)=>{state.panels[kind] = state.panels[kind].filter(x=>x.id!==id);
delete state.anchors[id];
renderPanels(); renderAll(); runChecks(); renderAudit();
};
function panelHtml(kind){
const list = state.panels[kind];
if(list.length===0) return `<div class="tiny muted">No items.</div>`;
return list.map(it=>`
<div class="item">
<div class="itemHead">
<div>
<span class="pill">${esc(it.kind)}</span>
<span class="pill mono">${it.confidence.toFixed(2)}</span>
<span class="pill">${esc(it.risk)}</span>
</div>
<div class="btnrow">
<button onclick="focusAnchor('${it.id}')">Show</button>
<button onclick="removeClaim('${kind}','${it.id}')">Remove</button>
</div>
</div>
<div>${esc(it.text)}</div>
${it.evidence ? `<div class="tiny"><span class="k">evidence</span>: ${esc(it.evidence)}</div>` : ``}
${it.because ? `<div class="tiny"><span class="k">because</span>: ${esc(it.because)}</div>` : ``}
${it.missing ? `<div class="tiny"><span class="k">missing</span>: ${esc(it.missing)}</div>` : ``}
${it.contradiction ? `<div class="tiny"><span class="k">contradiction</span>: ${esc(it.contradiction)}</div>` : ``}
${it.assumptions ? `<div class="tiny"><span class="k">assumptions</span>: ${esc(it.assumptions)}</div>` : ``}
<div class="tiny muted">source: ${esc(it.source)}</div></div>
`).join("");
}
window.focusAnchor = (id)=>{
const r = state.anchors[id];
if(!r) return;
state.selection = { ...r };
renderAll();
};
function renderPanels(){
$("ObservedList").innerHTML = panelHtml("Observed");
$("InferredList").innerHTML = panelHtml("Inferred");
$("UnknownList").innerHTML = panelHtml("Unknown");
$("PathList").innerHTML = panelHtml("Path");
}
// Checks and audit
function runChecks(){
const msgs = [];
const obs = state.panels.Observed;
const inf = state.panels.Inferred;
const unk = state.panels.Unknown;
if(!$("caseName").value.trim()) msgs.push({lvl:"warn", txt:"Case name is empty."});
if(!$("kidQ").value.trim()) msgs.push({lvl:"warn", txt:"Curiosity question is empty."});
if(!state.signal.loaded) msgs.push({lvl:"warn", txt:"No signal loaded."});
obs.forEach(it=>{
if(bannedInObserved(it.text)) msgs.push({lvl:"bad", txt:"Observed contains inference language."});
if(it.because && it.because.trim()) msgs.push({lvl:"warn", txt:"Observed should not rely on because."});
if(!it.evidence || !it.evidence.trim()) msgs.push({lvl:"warn", txt:"Observed missing evidence pointer."});
});
inf.forEach(it=>{
if(!it.because || it.because.trim().length<3) msgs.push({lvl:"bad", txt:"Inferred missing because."});
if(!it.contradiction || it.contradiction.trim().length<3) msgs.push({lvl:"warn", txt:"Add contradiction for an inferre
});
unk.forEach(it=>{
if(!it.missing || it.missing.trim().length<3) msgs.push({lvl:"bad", txt:"Unknown missing missing signal."});
});
if(msgs.length===0) msgs.push({lvl:"good", txt:"All integrity checks passed."});
$("checks").innerHTML = msgs.map(m=>{
const box = m.lvl==="bad" ? "boxBad" : (m.lvl==="warn" ? "boxWarn" : "boxGood");
const tag = m.lvl==="bad" ? "FAIL" : (m.lvl==="warn" ? "WARN" : "OK");
return `<div class="${box}"><b>${tag}</b> ${esc(m.txt)}</div>`;
}).join("<div style='height:8px'></div>");
}
$("runChecksBtn").addEventListener("click", ()=>{ runChecks(); renderAudit(); });
function renderAudit(){
let score = 100;
if(!$("caseName").value.trim()) score -= 10;
if(!$("kidQ").value.trim()) score -= 10;
if(!state.signal.loaded) score -= 8;
const all = Object.values(state.panels).flat();
all.forEach(it=>{
if(it.kind==="Observed" && (!it.evidence||!it.evidence.trim())) score -= 3;
if(it.kind==="Inferred" && (!it.because||it.because.trim().length<3)) score -= 6;
if(it.kind==="Unknown" && (!it.missing||it.missing.trim().length<3)) score -= 6;
});
score = Math.max(0, Math.min(100, score));
const grade = score>=90 ? "strong" : score>=75 ? "good" : score>=60 ? "weak" : "unsafe";
$("auditBox").innerHTML = `
<div class="boxGood">
<div class="tiny"><span class="k">Integrity score</span>: ${score}/100 <span class="k">grade</span>: ${grade}</div>
<div class="tiny muted">Score measures structure completeness, not truth of the world.</div>
</div>`;
}
$("calibrateBtn").addEventListener("click", ()=>{
const note = prompt("Calibration log entry. What was wrong or learned?");
if(!note) return;
state.calibration.push({ at: nowIso(), note });
$("calibration").innerHTML = state.calibration.slice(-6).reverse().map(x=>`
<div class="item"><div class="tiny mono">${esc(x.at)}</div><div>${esc(x.note)}</div></div>
`).join("");
});
// Import export$("exportBtn").addEventListener("click", ()=>{
const obj = {
meta: {
caseName: $("caseName").value.trim(),
scope: $("scopeTag").value,
curiosity: $("kidQ").value.trim(),
quality: $("sigNotes").value.trim(),
assumptionsGlobal: $("assumptionsGlobal").value.trim(),
constraintsGlobal: $("constraintsGlobal").value.trim()
},
signal: state.signal,
panels: state.panels,
anchors: state.anchors,
calibration: state.calibration
};
const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
const a = document.createElement("a");
a.href = URL.createObjectURL(blob);
a.download = (obj.meta.caseName ? obj.meta.caseName.replaceAll(" ","_") : "truth_engine_case") + ".json";
a.click();
});
$("importBtn").addEventListener("click", ()=>{
const inp = document.createElement("input");
inp.type = "file";
inp.accept = "application/json";
inp.onchange = () => {const f = inp.files && inp.files[0];
if(!f) return;
const reader = new FileReader();
reader.onload = () => {
try{
const obj = JSON.parse(reader.result);
if(!obj || !obj.panels) throw new Error("Invalid file");
$("caseName").value = obj.meta?.caseName || "";
$("scopeTag").value = obj.meta?.scope || "personal";
$("kidQ").value = obj.meta?.curiosity || "";
$("sigNotes").value = obj.meta?.quality || "";
$("assumptionsGlobal").value = obj.meta?.assumptionsGlobal || "";
$("constraintsGlobal").value = obj.meta?.constraintsGlobal || "";
state.panels = obj.panels || state.panels;
state.anchors = obj.anchors || {};
state.calibration = obj.calibration || [];
// Signal image cannot be restored from JSON intentionally.
state.signal.loaded = false;
state.signal.source = "none";
state.signal.timestamp = obj.signal?.timestamp || null;
setSigTime();
enableSignalUI(false);
renderPanels();
renderAll();
runChecks();
renderAudit();
}catch(err){
alert("Import failed: " + err.message);
}
};
reader.readAsText(f);
};
});
inp.click();
$("resetBtn").addEventListener("click", ()=>{
stopCamera();
state.signal = { loaded:false, w:0, h:0, timestamp:null, source:"none" };
state.panels = { Observed:[], Inferred:[], Unknown:[], Path:[] };
state.drafts = [];
state.calibration = [];
state.selection = null;
state.anchors = {};
$("caseName").value=""; $("kidQ").value=""; $("sigNotes").value="";
$("assumptionsGlobal").value=""; $("constraintsGlobal").value="";
$("checks").innerHTML=""; $("calibration").innerHTML=""; $("draftsBox").innerHTML="";
enableSignalUI(false);
setSigTime();
renderAll();
renderPanels();
renderAudit();
});
// Initial state
enableSignalUI(false);
setSigTime();
renderAll();
renderPanels();
renderAudit();
})();
</script>
</body>
</html>
