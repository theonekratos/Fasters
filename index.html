<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Truth Engine Mobile</title>
<style>
body{font-family:Arial,sans-serif;margin:12px;max-width:980px}
h1{font-size:18px;margin:0 0 8px 0}
.small{font-size:12px;color:#444}
.row{display:flex;flex-direction:column;gap:12px;margin-top:12px}
.card{border:1px solid #d0d0d0;border-radius:14px;padding:12px;background:#fff}
label{display:block;margin:10px 0 6px;font-weight:700;font-size:13px}
input[type=text],textarea,select{width:100%;box-sizing:border-box;padding:10px;border:1px solid #bdbdbd;border-radius:12px}
textarea{min-height:70px;resize:vertical}
button{padding:10px 12px;border:1px solid #444;border-radius:14px;background:#fff;cursor:pointer;font-size:14px}
button:disabled{opacity:.5;cursor:not-allowed}
.btnrow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.pill{display:inline-block;padding:3px 10px;border-radius:999px;border:1px solid #aaa;font-size:12px;margin-right:6px}
.mono{font-family:ui-monospace,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px}
.muted{color:#666}
.item{margin:10px 0;padding:10px;border:1px solid #ddd;border-radius:14px}
.itemHead{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.boxGood{background:#f1fff3;border:1px solid #c8e6c9;padding:10px;border-radius:14px}
.boxWarn{background:#fff8e1;border:1px solid #ffe0b2;padding:10px;border-radius:14px}
.boxBad{background:#fff5f5;border:1px solid #ffcdd2;padding:10px;border-radius:14px}
.tiny{font-size:11px;color:#555}
canvas{width:100%;height:auto;border-radius:12px;background:#fafafa;touch-action:none}
video{width:100%;height:auto;border-radius:12px;background:#000}
.grid2{display:grid;grid-template-columns:1fr;gap:10px}
@media (min-width:860px){ .row{flex-direction:row;align-items:flex-start} .left{flex:1.15} .right{flex:.85} .grid2{grid-template-columns:1fr 1fr} }
</style>
</head>
<body>
<h1>Truth Engine Mobile</h1>
<div class="small">Local only. No network calls. Assist drafts never become truth until you approve. Modalities are declared only after your request and the capability probe.</div>

<div class="item" style="margin-top:10px">
  <div class="itemHead">
    <div>
      <span class="pill">Safari status</span>
      <span class="pill mono" id="secStatus">checking</span>
    </div>
  </div>
  <div id="secBox" class="tiny muted"></div>
</div>

<div class="row">
  <div class="card left">

    <div class="itemHead">
      <div>
        <span class="pill">Signal</span>
        <span class="pill">Viewer</span>
        <span class="pill">Temporal</span>
        <span class="pill">Modalities</span>
      </div>
      <div class="btnrow">
        <button id="importBtn">Import JSON</button>
        <button id="exportBtn">Export JSON</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <label>Case name</label>
    <input id="caseName" type="text" placeholder="Example: Curtain test 01"/>

    <div class="grid2">
      <div>
        <label>Scope</label>
        <select id="scopeTag">
          <option value="personal">personal</option>
          <option value="private">private</option>
          <option value="shareable">shareable</option>
        </select>
      </div>
      <div>
        <label>Signal time</label>
        <input id="sigTime" type="text" readonly class="mono"/>
      </div>
    </div>

    <label>Curiosity question</label>
    <textarea id="kidQ" placeholder="What do you want to learn from this scene"></textarea>

    <label>Signal quality notes</label>
    <textarea id="sigNotes" placeholder="Occlusion, blur, glare, reflections, distance"></textarea>

    <div class="item">
      <div class="itemHead">
        <div>
          <span class="pill">Modalities requested</span>
          <span class="pill mono" id="modStatus">not probed</span>
        </div>
        <div class="btnrow">
          <button id="probeBtn">Probe capabilities</button>
        </div>
      </div>

      <div class="grid2">
        <div>
          <label class="tiny"><input id="reqDepth" type="checkbox"/> depth sensing</label>
          <label class="tiny"><input id="reqIR" type="checkbox"/> IR</label>
          <label class="tiny"><input id="reqPol" type="checkbox"/> polarization</label>
          <label class="tiny"><input id="reqActive" type="checkbox"/> active probing</label>
        </div>
        <div>
          <div id="modBox" class="tiny muted"></div>
        </div>
      </div>

      <div class="tiny muted">
        Note: on typical iOS web pages, IR and polarization are not exposed. Depth sensing is not reliably exposed. Active probing can sometimes include torch when supported. The probe will declare what is actually available.
      </div>
    </div>

    <label>Upload image</label>
    <input id="imgInput" type="file" accept="image/*"/>

    <div class="item">
      <div class="itemHead">
        <div>
          <span class="pill">Camera input</span>
          <span class="pill">Live</span>
          <span class="pill">Capture</span>
        </div>
      </div>

      <div class="btnrow" style="margin-top:8px">
        <button id="camStartBtn">Start live</button>
        <button id="camStopBtn" disabled>Stop</button>
        <button id="camGrabBtn" disabled>Capture frame</button>

        <input id="camFileInput" type="file" accept="image/*" capture="environment" style="display:none"/>
        <button id="camFileBtn" type="button">Open camera capture</button>

        <button id="swapCamBtn" disabled>Swap camera</button>
      </div>

      <div id="camMsg" class="tiny muted" style="margin-top:6px"></div>

      <video id="camView" muted playsinline style="display:none"></video>
      <canvas id="camGrabCanvas" style="display:none"></canvas>
    </div>

    <div class="item">
      <div class="itemHead">
        <div>
          <span class="pill">Temporal engine</span>
          <span class="pill">Invariance</span>
          <span class="pill">Resistance</span>
        </div>
        <div class="btnrow">
          <button id="tempStartBtn" disabled>Start temporal sampling</button>
          <button id="tempStopBtn" disabled>Stop temporal sampling</button>
          <button id="tempCommitBtn" disabled>Commit temporal evidence</button>
        </div>
      </div>
      <div class="tiny muted">Temporal sampling measures what changes and what refuses to change. It does not invent hidden content. It measures information gain.</div>
      <div id="tempBox" class="tiny muted" style="margin-top:8px"></div>
    </div>

    <div class="item" style="margin-top:10px">
      <div class="itemHead">
        <div>
          <span class="pill">Toggles</span>
          <span class="pill mono" id="viewerStatus">no signal</span>
        </div>
        <div class="btnrow">
          <button id="fitBtn" disabled>Fit</button>
          <button id="clearSelBtn" disabled>Clear selection</button>
        </div>
      </div>

      <div class="btnrow" style="margin:8px 0">
        <label class="tiny"><input id="edgeToggle" type="checkbox"/> edges</label>
        <label class="tiny"><input id="anchorToggle" type="checkbox" checked/> evidence anchors</label>
        <label class="tiny"><input id="deltaToggle" type="checkbox"/> delta overlay</label>
      </div>

      <label class="tiny">Zoom</label>
      <input id="zoomRange" type="range" min="10" max="400" value="100" disabled/>

      <canvas id="viewCanvas" width="720" height="520"></canvas>
      <canvas id="workCanvas" width="720" height="520" style="display:none"></canvas>

      <div id="regionBox" style="margin-top:10px"></div>
    </div>

    <div class="item">
      <div class="itemHead">
        <div>
          <span class="pill">Multi signal memory</span>
          <span class="pill">Compare</span>
        </div>
        <div class="btnrow">
          <button id="snapBtn" disabled>Save current as signal</button>
          <select id="sigA" disabled></select>
          <select id="sigB" disabled></select>
          <button id="loadA" disabled>Load A</button>
          <button id="loadB" disabled>Load B</button>
        </div>
      </div>
      <div id="memBox" class="tiny muted"></div>
    </div>

    <div class="itemHead">
      <div>
        <span class="pill">Assist Mode</span>
        <span class="pill">Drafts only</span>
      </div>
      <div class="btnrow">
        <button id="assistBtn" disabled>Generate drafts</button>
        <button id="clearDraftsBtn" disabled>Clear drafts</button>
      </div>
    </div>

    <div class="tiny muted">Drafts use measurable signal features. You must approve every claim.</div>
    <div id="draftsBox"></div>

    <label>Global assumptions</label>
    <textarea id="assumptionsGlobal" placeholder="Assumptions about the scene"></textarea>

    <label>Global constraints</label>
    <textarea id="constraintsGlobal" placeholder="Physics limits, sensor limits, privacy limits"></textarea>

    <div id="auditBox" style="margin-top:10px"></div>

    <div class="item">
      <div class="itemHead">
        <div>
          <span class="pill">Attempt log</span>
          <span class="pill">Negative capability</span>
        </div>
        <button id="clearAttemptsBtn">Clear attempts</button>
      </div>
      <div id="attemptBox" class="tiny muted"></div>
    </div>

  </div>

  <div class="card right">
    <div class="itemHead">
      <div>
        <span class="pill">Truth panels</span>
        <span class="pill">Governed</span>
      </div>
      <div class="btnrow">
        <button id="runChecksBtn">Run checks</button>
      </div>
    </div>

    <label>Panel</label>
    <select id="kind">
      <option value="Observed">Observed</option>
      <option value="Inferred">Inferred</option>
      <option value="Unknown">Unknown</option>
      <option value="Path">Path</option>
    </select>

    <label>Claim text</label>
    <textarea id="text"></textarea>

    <label>Evidence pointer</label>
    <textarea id="evidence" placeholder="Selection coords or region notes"></textarea>

    <div class="grid2">
      <div>
        <label>Because</label>
        <textarea id="because" placeholder="Required for Inferred"></textarea>
      </div>
      <div>
        <label>Missing signal</label>
        <textarea id="missing" placeholder="Required for Unknown"></textarea>
      </div>
    </div>

    <label>Contradiction</label>
    <textarea id="contradiction" placeholder="What would disprove this"></textarea>

    <label>Assumptions for this claim</label>
    <textarea id="assumptionsLocal"></textarea>

    <div class="grid2">
      <div>
        <label>Confidence</label>
        <input id="conf" type="range" min="0" max="100" value="70"/>
        <div class="tiny muted">Confidence: <span id="confVal">0.70</span></div>
      </div>
      <div>
        <label>Risk</label>
        <select id="risk">
          <option value="low">low</option>
          <option value="medium">medium</option>
          <option value="high">high</option>
        </select>
      </div>
    </div>

    <div class="btnrow" style="margin-top:10px">
      <button id="addBtn">Add</button>
      <button id="calibrateBtn">Calibration log</button>
    </div>

    <div id="checks" style="margin-top:10px"></div>
    <div id="calibration" style="margin-top:10px"></div>

    <div class="itemHead" style="margin-top:10px">
      <div><span class="pill" style="border-color:#2e7d32;color:#2e7d32">Observed</span></div>
      <button onclick="clearPanel('Observed')">Clear</button>
    </div>
    <div id="ObservedList"></div>

    <div class="itemHead" style="margin-top:10px">
      <div><span class="pill" style="border-color:#ef6c00;color:#ef6c00">Inferred</span></div>
      <button onclick="clearPanel('Inferred')">Clear</button>
    </div>
    <div id="InferredList"></div>

    <div class="itemHead" style="margin-top:10px">
      <div><span class="pill" style="border-color:#c62828;color:#c62828">Unknown</span></div>
      <button onclick="clearPanel('Unknown')">Clear</button>
    </div>
    <div id="UnknownList"></div>

    <div class="itemHead" style="margin-top:10px">
      <div><span class="pill">Paths</span></div>
      <button onclick="clearPanel('Path')">Clear</button>
    </div>
    <div id="PathList"></div>
  </div>
</div>

<script>
(() => {
const state = {
  signal: { loaded:false, w:0, h:0, timestamp:null, source:"none", id:null, dataUrl:null },
  panels: { Observed:[], Inferred:[], Unknown:[], Path:[] },
  drafts: [],
  calibration: [],
  selection: null,
  anchors: {},
  attempts: [],
  modalities: {
    requested: { depth:false, ir:false, pol:false, active:false },
    probed: false,
    available: { depth:false, ir:false, pol:false, active:false, camera:false, torch:false },
    notes: []
  },
  cam: { stream:null, active:false, facing:"environment" },
  temporal: { running:false, timer:null, samples:[], last:null, infoGain:0, resistance:0 },
  memory: { signals:[] },
  view: { zoom:1, panX:0, panY:0, dragging:false, lastX:0, lastY:0, selecting:false, pressTimer:null, selStart:null }
};

const $ = id => document.getElementById(id);
const viewCanvas = $("viewCanvas");
const vctx = viewCanvas.getContext("2d");
const workCanvas = $("workCanvas");
const wctx = workCanvas.getContext("2d");
const camView = $("camView");
const camMsg = $("camMsg");
const camGrabCanvas = $("camGrabCanvas");
const gctx = camGrabCanvas.getContext("2d");
const img = new Image();
img.crossOrigin = "anonymous";

function nowIso(){ return new Date().toISOString(); }
function esc(s){ return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

const conf = $("conf");
const confVal = $("confVal");
conf.addEventListener("input", ()=> confVal.textContent = (Number(conf.value)/100).toFixed(2));
conf.dispatchEvent(new Event("input"));

function addAttempt(kind, detail, ok, extra){
  state.attempts.push({ at: nowIso(), kind, detail, ok: !!ok, extra: extra || {} });
  renderAttempts();
}
function renderAttempts(){
  const box = $("attemptBox");
  if(state.attempts.length === 0){
    box.innerHTML = `<div class="tiny muted">No attempts yet.</div>`;
    return;
  }
  const last = state.attempts.slice(-12).reverse();
  box.innerHTML = last.map(a => {
    const tag = a.ok ? "OK" : "FAIL";
    const cls = a.ok ? "boxGood" : "boxWarn";
    return `<div class="${cls}"><div class="tiny mono">${esc(a.at)}</div><div class="tiny"><b>${tag}</b> ${esc(a.kind)}: ${esc(a.detail)}</div></div>`;
  }).join("<div style='height:8px'></div>");
}

function setSigTime(){
  $("sigTime").value = state.signal.timestamp || "";
  $("viewerStatus").textContent = state.signal.loaded ? ("signal " + state.signal.source) : "no signal";
}
function enableSignalUI(on){
  $("fitBtn").disabled = !on;
  $("clearSelBtn").disabled = !on;
  $("zoomRange").disabled = !on;
  $("assistBtn").disabled = !on;
  $("clearDraftsBtn").disabled = !on;
  $("snapBtn").disabled = !on;
}
function updateMemorySelectors(){
  const a = $("sigA");
  const b = $("sigB");
  const sigs = state.memory.signals;
  a.innerHTML = "";
  b.innerHTML = "";
  sigs.forEach(s => {
    const optA = document.createElement("option");
    optA.value = s.id;
    optA.textContent = s.name;
    a.appendChild(optA);
    const optB = document.createElement("option");
    optB.value = s.id;
    optB.textContent = s.name;
    b.appendChild(optB);
  });
  const has = sigs.length > 0;
  a.disabled = !has;
  b.disabled = !has;
  $("loadA").disabled = !has;
  $("loadB").disabled = !has;
  $("memBox").innerHTML = has
    ? `<div class="tiny">Saved signals: ${sigs.length}. Use Load A and Load B to compare with delta overlay.</div>`
    : `<div class="tiny muted">No saved signals yet.</div>`;
}
function loadSignalById(id){
  const s = state.memory.signals.find(x => x.id === id);
  if(!s) return;
  loadImage(s.dataUrl, "memory " + s.name, s.id, s.dataUrl);
}

function loadImage(src, source, idOpt, dataUrlOpt){
  img.onload = () => {
    state.signal.loaded = true;
    state.signal.w = img.naturalWidth || img.width;
    state.signal.h = img.naturalHeight || img.height;
    state.signal.timestamp = nowIso();
    state.signal.source = source || "upload";
    state.signal.id = idOpt || null;
    state.signal.dataUrl = dataUrlOpt || null;
    state.selection = null;
    setSigTime();
    enableSignalUI(true);
    fit();
    renderAll();
    runChecks();
    renderAudit();
    addAttempt("signal load", state.signal.source, true, { w: state.signal.w, h: state.signal.h });
  };
  img.onerror = () => {
    addAttempt("signal load", "image failed to load", false, {});
    alert("Image failed to load.");
  };
  img.src = src;
}

$("imgInput").addEventListener("change", (e) => {
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  loadImage(url, "upload", null, null);
  stopLiveCamera();
});

function isSafari(){
  const ua = navigator.userAgent;
  const isIOS = /iPad|iPhone|iPod/.test(ua);
  const isWebKit = /WebKit/.test(ua);
  const isChromeIOS = /CriOS/.test(ua);
  const isFirefoxIOS = /FxiOS/.test(ua);
  return (isIOS && isWebKit && !isChromeIOS && !isFirefoxIOS) || (/Safari/.test(ua) && /Apple/.test(navigator.vendor) && !/Chrome/.test(ua));
}

function updateSecureUI(){
  const sec = window.isSecureContext;
  const hasMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
  const okLive = sec && hasMedia;

  $("secStatus").textContent = okLive ? "live camera allowed" : "live camera blocked";
  const reasons = [];
  if(!sec) reasons.push("This page is not a secure context. Live camera needs https or localhost.");
  if(!hasMedia) reasons.push("mediaDevices getUserMedia is unavailable in this browser.");
  const safariLine = isSafari() ? "Safari detected." : "Non Safari browser detected.";
  const rec = okLive
    ? "You can use Start live."
    : "Use Open camera capture, or host on GitHub Pages with https.";

  $("secBox").innerHTML = `
    <div class="${okLive ? "boxGood" : "boxWarn"}">
      <div class="tiny"><b>${esc(safariLine)}</b></div>
      ${reasons.length ? `<div class="tiny">${esc(reasons.join(" "))}</div>` : `<div class="tiny">Secure context and camera API look available.</div>`}
      <div class="tiny muted">${esc(rec)}</div>
    </div>
  `;

  $("camStartBtn").disabled = !okLive;
  if(!okLive){
    $("tempStartBtn").disabled = true;
    $("swapCamBtn").disabled = true;
  }
}

async function probeModalities(){
    // SAFARI: motion permission must be requested inside user gesture
  if (typeof DeviceMotionEvent !== "undefined" &&
      typeof DeviceMotionEvent.requestPermission === "function") {
    try {
      const response = await DeviceMotionEvent.requestPermission();
      if (response === "granted") {
        console.log("Motion access granted");
        state.modalities.notes.push("motion/orientation access granted");
      } else {
        console.log("Motion access denied");
        state.modalities.notes.push("motion/orientation access denied");
      }
    } catch (err) {
      console.error(err);
      state.modalities.notes.push("motion/orientation request failed");
    }
  }
  state.modalities.requested.depth = $("reqDepth").checked;
  state.modalities.requested.ir = $("reqIR").checked;
  state.modalities.requested.pol = $("reqPol").checked;
  state.modalities.requested.active = $("reqActive").checked;

  state.modalities.probed = true;
  state.modalities.notes = [];
  state.modalities.available = { depth:false, ir:false, pol:false, active:false, camera:false, torch:false };

  const notes = state.modalities.notes;

  const hasMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
  state.modalities.available.camera = hasMedia && window.isSecureContext;
  if(!window.isSecureContext) notes.push("not secure context, live camera will be blocked");
  if(!hasMedia) notes.push("mediaDevices not available");

  state.modalities.available.depth = false;
  notes.push("depth sensing is not exposed in typical iOS Safari web pages");

  state.modalities.available.ir = false;
  notes.push("IR is not exposed in standard web APIs");
  state.modalities.available.pol = false;
  notes.push("polarization is not exposed in standard web APIs");

  try{
    const devices = (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) ? await navigator.mediaDevices.enumerateDevices() : [];
    if(devices && devices.length) notes.push("devices enumerated");
  }catch{
    notes.push("devices enumeration blocked");
  }

  state.modalities.available.active = false;
  state.modalities.available.torch = false;
  notes.push("active probing torch can only be tested after live camera starts");

  renderModalities();
  addAttempt("capability probe", "modalities probed", true, { requested: state.modalities.requested, available: state.modalities.available, notes });
}

function renderModalities(){
  const box = $("modBox");
  const s = state.modalities;
  const req = s.requested;
  const av = s.available;

  let lines = [];
  lines.push(`<div class="tiny"><b>Requested</b> depth ${req.depth} IR ${req.ir} pol ${req.pol} active ${req.active}</div>`);
  lines.push(`<div class="tiny"><b>Available</b> depth ${av.depth} IR ${av.ir} pol ${av.pol} active ${av.active} camera ${av.camera} torch ${av.torch}</div>`);

  const unmet = [];
  if(req.depth && !av.depth) unmet.push("depth unavailable");
  if(req.ir && !av.ir) unmet.push("IR unavailable");
  if(req.pol && !av.pol) unmet.push("polarization unavailable");
  if(req.active && !av.active) unmet.push("active probing unavailable or not yet verified");

  if(unmet.length){
    lines.push(`<div class="tiny boxWarn"><b>Declared unavailable after probe</b>: ${esc(unmet.join(", "))}</div>`);
    $("modStatus").textContent = "probed with unavailable declared";
  }else{
    $("modStatus").textContent = "probed";
  }

  if(s.notes.length){
    lines.push(`<div class="tiny muted">${esc(s.notes.join(" | "))}</div>`);
  }

  box.innerHTML = lines.join("");
}

$("probeBtn").addEventListener("click", probeModalities);

async function startLiveCamera(){
  updateSecureUI();
  if($("camStartBtn").disabled){
    camMsg.textContent = "Live camera is blocked here. Use Open camera capture, or host this page on https.";
    addAttempt("camera", "start blocked by secure context check", false, {});
    return;
  }

  camMsg.textContent = "Starting live camera.";
  addAttempt("camera", "start requested", true, { facing: state.cam.facing });

  try{
    const constraints = { video:{ facingMode: state.cam.facing }, audio:false };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);

    state.cam.stream = stream;
    state.cam.active = true;

    camView.srcObject = stream;
    camView.style.display = "block";
    await camView.play();

    $("camStartBtn").disabled = true;
    $("camStopBtn").disabled = false;
    $("camGrabBtn").disabled = false;
    $("swapCamBtn").disabled = false;
    $("tempStartBtn").disabled = false;

    camMsg.textContent = "Live camera active. Capture frame or run temporal sampling.";

    if(state.modalities.probed && state.modalities.requested.active){
      try{
        const track = stream.getVideoTracks()[0];
        const caps = track.getCapabilities ? track.getCapabilities() : {};
        const torchSupported = !!caps.torch;
        state.modalities.available.active = torchSupported;
        state.modalities.available.torch = torchSupported;
        state.modalities.notes.push(torchSupported ? "torch supported on this track" : "torch not supported on this track");
        renderModalities();
        addAttempt("active probing", torchSupported ? "torch supported" : "torch not supported", torchSupported, {});
      }catch{
        state.modalities.notes.push("torch capability check failed");
        renderModalities();
        addAttempt("active probing", "torch capability check failed", false, {});
      }
    }

  }catch(err){
    camMsg.textContent = "Camera error: " + err.message;
    addAttempt("camera", "start failed: " + err.message, false, {});
    alert(camMsg.textContent);
  }
}

function stopLiveCamera(){
  if(state.cam.stream){
    state.cam.stream.getTracks().forEach(t => t.stop());
  }
  state.cam.stream = null;
  state.cam.active = false;

  camView.pause();
  camView.srcObject = null;
  camView.style.display = "none";

  updateSecureUI();
  $("camStopBtn").disabled = true;
  $("camGrabBtn").disabled = true;

  $("tempStartBtn").disabled = true;
  $("tempStopBtn").disabled = true;
  $("tempCommitBtn").disabled = true;

  camMsg.textContent = "Camera stopped.";
  addAttempt("camera", "stopped", true, {});
}

function captureLiveFrame(){
  if(!state.cam.active || !camView.videoWidth) return;

  camGrabCanvas.width = camView.videoWidth;
  camGrabCanvas.height = camView.videoHeight;
  gctx.drawImage(camView, 0, 0);

  const dataUrl = camGrabCanvas.toDataURL("image/png");
  loadImage(dataUrl, "camera", null, dataUrl);
  addAttempt("camera", "frame captured", true, { w: camGrabCanvas.width, h: camGrabCanvas.height });
}

async function swapCamera(){
  state.cam.facing = (state.cam.facing === "environment") ? "user" : "environment";
  addAttempt("camera", "swap requested to " + state.cam.facing, true, {});
  stopLiveCamera();
  await startLiveCamera();
}

$("camStartBtn").addEventListener("click", startLiveCamera);
$("camStopBtn").addEventListener("click", stopLiveCamera);
$("camGrabBtn").addEventListener("click", captureLiveFrame);
$("swapCamBtn").addEventListener("click", swapCamera);

$("camFileBtn").addEventListener("click", ()=> $("camFileInput").click());
$("camFileInput").addEventListener("change", (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  loadImage(url, "camera capture", null, null);
  addAttempt("camera", "capture used", true, {});
});

function fit(){
  if(!state.signal.loaded) return;
  const cw = viewCanvas.width, ch = viewCanvas.height;
  const iw = state.signal.w, ih = state.signal.h;
  const s = Math.min(cw/iw, ch/ih);
  state.view.zoom = s;
  $("zoomRange").value = Math.max(10, Math.min(400, Math.round(s*100)));
  state.view.panX = (cw - iw*s)/2;
  state.view.panY = (ch - ih*s)/2;
}

$("fitBtn").addEventListener("click", ()=>{ fit(); renderAll(); });
$("zoomRange").addEventListener("input", ()=>{
  state.view.zoom = Number($("zoomRange").value)/100;
  renderAll();
});

function canvasToImage(cx, cy){
  const z = state.view.zoom;
  return { x:(cx - state.view.panX)/z, y:(cy - state.view.panY)/z };
}
function clampRect(r){
  const x = Math.max(0, Math.min(state.signal.w, r.x));
  const y = Math.max(0, Math.min(state.signal.h, r.y));
  const w = Math.max(0, Math.min(state.signal.w - x, r.w));
  const h = Math.max(0, Math.min(state.signal.h - y, r.h));
  return { x, y, w, h };
}
function clearPressTimer(){
  if(state.view.pressTimer){ clearTimeout(state.view.pressTimer); state.view.pressTimer = null; }
}
function beginSelectAt(cx, cy){
  const p = canvasToImage(cx, cy);
  state.view.selecting = true;
  state.view.selStart = { x:p.x, y:p.y };
  state.selection = { x:p.x, y:p.y, w:0, h:0 };
}
function updateSelectTo(cx, cy){
  const p = canvasToImage(cx, cy);
  const sx = state.view.selStart.x, sy = state.view.selStart.y;
  const x = Math.min(sx, p.x), y = Math.min(sy, p.y);
  const w = Math.abs(p.x - sx), h = Math.abs(p.y - sy);
  state.selection = clampRect({ x, y, w, h });
}

viewCanvas.addEventListener("pointerdown", (ev)=>{
  if(!state.signal.loaded) return;
  ev.preventDefault();
  const r = viewCanvas.getBoundingClientRect();
  const cx = ev.clientX - r.left, cy = ev.clientY - r.top;
  state.view.dragging = true;
  state.view.lastX = cx; state.view.lastY = cy;
  state.view.selecting = false;
  state.view.selStart = null;
  clearPressTimer();
  state.view.pressTimer = setTimeout(()=>{ beginSelectAt(cx, cy); renderAll(); }, 320);
});
viewCanvas.addEventListener("pointermove", (ev)=>{
  if(!state.signal.loaded || !state.view.dragging) return;
  ev.preventDefault();
  const r = viewCanvas.getBoundingClientRect();
  const cx = ev.clientX - r.left, cy = ev.clientY - r.top;
  if(state.view.selecting && state.view.selStart){
    updateSelectTo(cx, cy);
    renderAll();
    return;
  }
  clearPressTimer();
  const dx = cx - state.view.lastX, dy = cy - state.view.lastY;
  state.view.lastX = cx; state.view.lastY = cy;
  state.view.panX += dx; state.view.panY += dy;
  renderAll();
});
function endDrag(ev){
  if(!state.signal.loaded) return;
  ev.preventDefault();
  clearPressTimer();
  state.view.dragging = false;
  state.view.selecting = false;
  state.view.selStart = null;
  renderAll();
}
viewCanvas.addEventListener("pointerup", endDrag);
viewCanvas.addEventListener("pointercancel", endDrag);

$("clearSelBtn").addEventListener("click", ()=>{
  state.selection = null;
  renderAll();
});

function drawImage(){
  vctx.clearRect(0,0,viewCanvas.width,viewCanvas.height);
  if(!state.signal.loaded){
    vctx.fillStyle = "#666";
    vctx.font = "14px Arial";
    vctx.fillText("Load an image or capture a frame.", 16, 28);
    return;
  }
  const z = state.view.zoom;
  vctx.save();
  vctx.translate(state.view.panX, state.view.panY);
  vctx.scale(z, z);
  vctx.drawImage(img, 0, 0);
  vctx.restore();
}

function edgeOverlay(){
  const iw = state.signal.w, ih = state.signal.h;
  const maxDim = 640;
  const s = Math.min(1, maxDim / Math.max(iw, ih));
  const w = Math.max(1, Math.floor(iw*s));
  const h = Math.max(1, Math.floor(ih*s));
  const c = document.createElement("canvas");
  c.width = w; c.height = h;
  const ctx = c.getContext("2d");
  ctx.drawImage(img,0,0,w,h);
  const id = ctx.getImageData(0,0,w,h);
  const d = id.data;
  const lum = new Float32Array(w*h);
  for(let i=0,p=0;i<w*h;i++,p+=4){
    lum[i] = 0.2126*d[p] + 0.7152*d[p+1] + 0.0722*d[p+2];
  }
  const out = ctx.createImageData(w,h);
  const o = out.data;
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const i = y*w+x;
      const gx = (lum[i+1]-lum[i-1]) + 2*(lum[i+1+w]-lum[i-1+w]) + (lum[i+1-w]-lum[i-1-w]);
      const gy = (lum[i+w]-lum[i-w]) + 2*(lum[i+w+1]-lum[i-w+1]) + (lum[i+w-1]-lum[i-w-1]);
      const mag = Math.min(255, Math.abs(gx) + Math.abs(gy));
      const p = i*4;
      o[p]=255; o[p+1]=255; o[p+2]=255; o[p+3]=mag > 140 ? 180 : 0;
    }
  }
  ctx.putImageData(out,0,0);

  const z = state.view.zoom;
  vctx.save();
  vctx.translate(state.view.panX, state.view.panY);
  vctx.scale(z, z);
  vctx.globalAlpha = 0.9;
  vctx.drawImage(c, 0, 0, iw, ih);
  vctx.globalAlpha = 1;
  vctx.restore();
}

function drawSelection(){
  if(!state.selection) return;
  const z = state.view.zoom;
  vctx.save();
  vctx.strokeStyle = "#1976d2";
  vctx.lineWidth = 2;
  vctx.setLineDash([6,4]);
  vctx.strokeRect(
    state.view.panX + state.selection.x*z,
    state.view.panY + state.selection.y*z,
    state.selection.w*z,
    state.selection.h*z
  );
  vctx.setLineDash([]);
  vctx.restore();
}

function drawAnchors(){
  if(!$("anchorToggle").checked) return;
  const z = state.view.zoom;
  vctx.save();
  vctx.strokeStyle = "#8e24aa";
  vctx.lineWidth = 2;
  for(const id in state.anchors){
    const r = state.anchors[id];
    vctx.strokeRect(
      state.view.panX + r.x*z,
      state.view.panY + r.y*z,
      r.w*z,
      r.h*z
    );
  }
  vctx.restore();
}

function renderRegion(){
  const box = $("regionBox");
  if(!state.signal.loaded){
    box.innerHTML = `<div class="tiny muted">No signal loaded.</div>`;
    return;
  }
  const rect = state.selection || { x:0, y:0, w:state.signal.w, h:state.signal.h };
  const s = regionStats(rect);
  const selText = state.selection
    ? `selection x:${rect.x.toFixed(1)} y:${rect.y.toFixed(1)} w:${rect.w.toFixed(1)} h:${rect.h.toFixed(1)}`
    : "full image";

  box.innerHTML = `
    <div class="boxGood">
      <div class="tiny"><b>Region</b>: ${esc(selText)}</div>
      <div class="tiny"><b>Brightness mean</b>: ${s.mean.toFixed(1)} <b>std</b>: ${s.std.toFixed(1)} <b>min</b>: ${s.min.toFixed(0)} <b>max</b>: ${s.max.toFixed(0)}</div>
      <div class="tiny"><b>Edge density</b>: ${s.edgeDensity.toFixed(4)}</div>
      <div class="tiny muted">Tip: long press then drag to select a region. Evidence pointer can reference these numbers.</div>
    </div>
  `;
}

function regionStats(rect){
  const x = Math.max(0, Math.floor(rect.x));
  const y = Math.max(0, Math.floor(rect.y));
  const w = Math.max(1, Math.floor(rect.w));
  const h = Math.max(1, Math.floor(rect.h));

  const maxPix = 900*900;
  let rw = w, rh = h, scale = 1;
  if(w*h > maxPix){
    scale = Math.sqrt(maxPix / (w*h));
    rw = Math.max(1, Math.floor(w*scale));
    rh = Math.max(1, Math.floor(h*scale));
  }

  workCanvas.width = rw;
  workCanvas.height = rh;
  wctx.drawImage(img, x, y, w, h, 0, 0, rw, rh);

  const id = wctx.getImageData(0,0,rw,rh);
  const d = id.data;

  let sum=0,sum2=0,min=255,max=0;
  const lum = new Float32Array(rw*rh);
  for(let i=0,p=0;i<rw*rh;i++,p+=4){
    const L = 0.2126*d[p] + 0.7152*d[p+1] + 0.0722*d[p+2];
    lum[i]=L;
    sum += L;
    sum2 += L*L;
    if(L < min) min = L;
    if(L > max) max = L;
  }
  const mean = sum/(rw*rh);
  const variance = Math.max(0,(sum2/(rw*rh))-mean*mean);
  const std = Math.sqrt(variance);

  let edges=0;
  for(let yy=1; yy<rh-1; yy++){
    for(let xx=1; xx<rw-1; xx++){
      const i = yy*rw+xx;
      const gx = (lum[i+1]-lum[i-1]) + (lum[i+1+rw]-lum[i-1+rw]) + (lum[i+1-rw]-lum[i-1-rw]);
      const gy = (lum[i+rw]-lum[i-rw]) + (lum[i+rw+1]-lum[i-rw+1]) + (lum[i+rw-1]-lum[i-rw-1]);
      const mag = Math.abs(gx) + Math.abs(gy);
      if(mag > 80) edges++;
    }
  }
  const edgeDensity = edges / Math.max(1,(rw-2)*(rh-2));
  return { mean, std, min, max, edgeDensity };
}

function drawDeltaOverlay(){
  if(!$("deltaToggle").checked) return;
  const aId = $("sigA").value;
  const bId = $("sigB").value;
  const a = state.memory.signals.find(x=>x.id===aId);
  const b = state.memory.signals.find(x=>x.id===bId);
  if(!a || !b) return;

  const tmpA = new Image();
  const tmpB = new Image();
  let loaded = 0;

  function done(){
    if(loaded !== 2) return;

    const c = document.createElement("canvas");
    c.width = 360;
    c.height = 260;
    const ctx = c.getContext("2d");

    ctx.drawImage(tmpA, 0, 0, c.width, c.height);
    const idA = ctx.getImageData(0,0,c.width,c.height);

    ctx.clearRect(0,0,c.width,c.height);
    ctx.drawImage(tmpB, 0, 0, c.width, c.height);
    const idB = ctx.getImageData(0,0,c.width,c.height);

    const out = ctx.createImageData(c.width,c.height);
    for(let i=0;i<out.data.length;i+=4){
      const da = Math.abs(idA.data[i] - idB.data[i]) + Math.abs(idA.data[i+1] - idB.data[i+1]) + Math.abs(idA.data[i+2] - idB.data[i+2]);
      const v = Math.min(255, da);
      out.data[i]=255;
      out.data[i+1]=255;
      out.data[i+2]=255;
      out.data[i+3]=v > 60 ? 160 : 0;
    }
    ctx.putImageData(out,0,0);

    const z = state.view.zoom;
    vctx.save();
    vctx.translate(state.view.panX, state.view.panY);
    vctx.scale(z, z);
    vctx.globalAlpha = 0.8;
    vctx.drawImage(c, 0, 0, state.signal.w, state.signal.h);
    vctx.globalAlpha = 1;
    vctx.restore();
  }

  tmpA.onload = ()=>{ loaded++; done(); };
  tmpB.onload = ()=>{ loaded++; done(); };
  tmpA.src = a.dataUrl;
  tmpB.src = b.dataUrl;
}

function renderAll(){
  drawImage();
  if(state.signal.loaded && $("edgeToggle").checked) edgeOverlay();
  if(state.signal.loaded) drawAnchors();
  if(state.signal.loaded) drawSelection();
  if(state.signal.loaded) drawDeltaOverlay();
  renderRegion();
  renderDrafts();
  renderPanels();
  setSigTime();
}

function bannedInObserved(text){
  const t = (text||"").toLowerCase();
  const banned = ["maybe","likely","probably","could be","might be","i think","i guess","suggests"];
  return banned.some(w=>t.includes(w));
}

function makeDrafts(){
  const rect = state.selection || { x:0, y:0, w:state.signal.w, h:state.signal.h };
  const s = regionStats(rect);
  const regionRef = state.selection ? "selection" : "full image";

  const drafts = [];
  drafts.push({
    kind:"Observed",
    text:`Region brightness mean is about ${s.mean.toFixed(1)} on a 0 to 255 scale.`,
    evidence:`assist metrics for ${regionRef}: mean ${s.mean.toFixed(1)}, std ${s.std.toFixed(1)}`,
    because:"",
    missing:"",
    contradiction:"If exposure was heavily altered, brightness stats may not represent scene lighting.",
    assumptions:"Pixel luminance correlates with exposure.",
    confidence:0.70,
    risk:"low",
    anchor: state.selection ? { ...state.selection } : null
  });

  drafts.push({
    kind:"Observed",
    text:`Region edge density is about ${s.edgeDensity.toFixed(4)}.`,
    evidence:`assist metrics for ${regionRef}: edge density ${s.edgeDensity.toFixed(4)}`,
    because:"",
    missing:"A second view can confirm whether edges are real boundaries or artifacts.",
    contradiction:"Compression or noise can create false edges.",
    assumptions:"Edge density correlates with visible boundaries.",
    confidence:0.62,
    risk:"low",
    anchor: state.selection ? { ...state.selection } : null
  });

  drafts.push({
    kind:"Unknown",
    text:"Details hidden by occlusion cannot be determined from this single signal.",
    evidence:"information is absent where the signal is blocked",
    because:"",
    missing:"A new viewpoint, moving the occluder, or another sensing modality.",
    contradiction:"If a new signal reveals the hidden area, this becomes known.",
    assumptions:"Occlusion blocks information flow.",
    confidence:0.90,
    risk:"low",
    anchor:null
  });

  drafts.push({
    kind:"Path",
    text:"Path: capture a second signal and compare deltas to reduce ambiguity.",
    evidence:"difference across signals reduces occlusion uncertainty",
    because:"Multi signal comparison can invalidate false interpretations.",
    missing:"",
    contradiction:"If you cannot capture another signal, this path is unavailable.",
    assumptions:"You can provide another signal.",
    confidence:0.70,
    risk:"low",
    anchor:null
  });

  return drafts;
}

function renderDrafts(){
  const box = $("draftsBox");
  if(!state.signal.loaded){
    box.innerHTML = `<div class="tiny muted">Load a signal to enable drafts.</div>`;
    return;
  }
  if(state.drafts.length===0){
    box.innerHTML = `<div class="tiny muted">No drafts yet.</div>`;
    return;
  }
  box.innerHTML = state.drafts.map((d, idx)=>`
    <div class="item">
      <div class="itemHead">
        <div>
          <span class="pill">${esc(d.kind)} draft</span>
          <span class="pill mono">${d.confidence.toFixed(2)}</span>
          <span class="pill">${esc(d.risk)}</span>
        </div>
        <div class="btnrow">
          <button onclick="prefillDraft(${idx})">Prefill</button>
          <button onclick="approveDraft(${idx})">Approve</button>
        </div>
      </div>
      <div>${esc(d.text)}</div>
      <div class="tiny"><b>evidence</b>: ${esc(d.evidence)}</div>
      ${d.because ? `<div class="tiny"><b>because</b>: ${esc(d.because)}</div>` : ``}
      ${d.missing ? `<div class="tiny"><b>missing</b>: ${esc(d.missing)}</div>` : ``}
      ${d.contradiction ? `<div class="tiny"><b>contradiction</b>: ${esc(d.contradiction)}</div>` : ``}
      ${d.assumptions ? `<div class="tiny"><b>assumptions</b>: ${esc(d.assumptions)}</div>` : ``}
      <div class="tiny muted">Draft is not valid until approved.</div>
    </div>
  `).join("");
}

$("assistBtn").addEventListener("click", ()=>{
  state.drafts = makeDrafts();
  renderDrafts();
  addAttempt("assist", "drafts generated", true, {});
});
$("clearDraftsBtn").addEventListener("click", ()=>{
  state.drafts = [];
  renderDrafts();
  addAttempt("assist", "drafts cleared", true, {});
});

window.prefillDraft = (idx)=>{
  const d = state.drafts[idx];
  if(!d) return;
  $("kind").value = d.kind;
  $("text").value = d.text;
  $("evidence").value = d.evidence;
  $("because").value = d.because || "";
  $("missing").value = d.missing || "";
  $("contradiction").value = d.contradiction || "";
  $("assumptionsLocal").value = d.assumptions || "";
  conf.value = Math.round(d.confidence*100);
  conf.dispatchEvent(new Event("input"));
  $("risk").value = d.risk || "low";
  if(d.anchor){
    state.selection = { ...d.anchor };
    renderAll();
  }
};

window.approveDraft = (idx)=>{
  const d = state.drafts[idx];
  if(!d) return;

  if(d.kind==="Observed"){
    if(!d.evidence) return alert("Observed needs evidence pointer.");
    if(bannedInObserved(d.text)) return alert("Observed cannot contain inference language.");
  }
  if(d.kind==="Inferred" && (!d.because || d.because.length<3)) return alert("Inferred needs because.");
  if(d.kind==="Unknown" && (!d.missing || d.missing.length<3)) return alert("Unknown needs missing signal.");

  const claimId = crypto.randomUUID();
  state.panels[d.kind].push({
    id: claimId,
    kind: d.kind,
    text: d.text,
    evidence: d.evidence,
    because: d.because || "",
    missing: d.missing || "",
    contradiction: d.contradiction || "",
    assumptions: d.assumptions || "",
    confidence: d.confidence,
    risk: d.risk,
    source: "assist approved",
    at: nowIso()
  });

  if(d.anchor){
    state.anchors[claimId] = { ...d.anchor };
  }

  renderPanels();
  renderAll();
  runChecks();
  renderAudit();
  addAttempt("approval", "draft approved into " + d.kind, true, {});
};

$("addBtn").addEventListener("click", ()=>{
  const kind = $("kind").value;
  const text = $("text").value.trim();
  if(!text) return alert("Write claim text.");
  if(kind==="Observed" && bannedInObserved(text)) return alert("Observed cannot contain inference language.");
  if(kind==="Inferred" && $("because").value.trim().length<3) return alert("Inferred needs because.");
  if(kind==="Unknown" && $("missing").value.trim().length<3) return alert("Unknown needs missing signal.");

  const claimId = crypto.randomUUID();
  state.panels[kind].push({
    id: claimId,
    kind,
    text,
    evidence: $("evidence").value.trim(),
    because: $("because").value.trim(),
    missing: $("missing").value.trim(),
    contradiction: $("contradiction").value.trim(),
    assumptions: $("assumptionsLocal").value.trim(),
    confidence: Number(conf.value)/100,
    risk: $("risk").value,
    source: "manual",
    at: nowIso()
  });

  if(state.selection){
    state.anchors[claimId] = { ...state.selection };
  }

  $("text").value=""; $("evidence").value=""; $("because").value=""; $("missing").value="";
  $("contradiction").value=""; $("assumptionsLocal").value="";

  renderPanels();
  renderAll();
  runChecks();
  renderAudit();
  addAttempt("manual", "claim added to " + kind, true, {});
});

window.clearPanel = (kind)=>{
  state.panels[kind] = [];
  state.anchors = {};
  renderPanels(); renderAll(); runChecks(); renderAudit();
  addAttempt("panel", "cleared " + kind, true, {});
};

window.removeClaim = (kind, id)=>{
  state.panels[kind] = state.panels[kind].filter(x=>x.id!==id);
  delete state.anchors[id];
  renderPanels(); renderAll(); runChecks(); renderAudit();
  addAttempt("panel", "removed claim from " + kind, true, {});
};

function panelHtml(kind){
  const list = state.panels[kind];
  if(list.length===0) return `<div class="tiny muted">No items.</div>`;
  return list.map(it=>`
    <div class="item">
      <div class="itemHead">
        <div>
          <span class="pill">${esc(it.kind)}</span>
          <span class="pill mono">${it.confidence.toFixed(2)}</span>
          <span class="pill">${esc(it.risk)}</span>
        </div>
        <div class="btnrow">
          <button onclick="focusAnchor('${it.id}')">Show</button>
          <button onclick="removeClaim('${kind}','${it.id}')">Remove</button>
        </div>
      </div>
      <div>${esc(it.text)}</div>
      ${it.evidence ? `<div class="tiny"><b>evidence</b>: ${esc(it.evidence)}</div>` : ``}
      ${it.because ? `<div class="tiny"><b>because</b>: ${esc(it.because)}</div>` : ``}
      ${it.missing ? `<div class="tiny"><b>missing</b>: ${esc(it.missing)}</div>` : ``}
      ${it.contradiction ? `<div class="tiny"><b>contradiction</b>: ${esc(it.contradiction)}</div>` : ``}
      ${it.assumptions ? `<div class="tiny"><b>assumptions</b>: ${esc(it.assumptions)}</div>` : ``}
      <div class="tiny muted">source: ${esc(it.source)}</div>
    </div>
  `).join("");
}

window.focusAnchor = (id)=>{
  const r = state.anchors[id];
  if(!r) return;
  state.selection = { ...r };
  renderAll();
};

function renderPanels(){
  $("ObservedList").innerHTML = panelHtml("Observed");
  $("InferredList").innerHTML = panelHtml("Inferred");
  $("UnknownList").innerHTML = panelHtml("Unknown");
  $("PathList").innerHTML = panelHtml("Path");
}

function runChecks(){
  const msgs = [];
  const obs = state.panels.Observed;
  const inf = state.panels.Inferred;
  const unk = state.panels.Unknown;

  if(!$("caseName").value.trim()) msgs.push({lvl:"warn", txt:"Case name is empty."});
  if(!$("kidQ").value.trim()) msgs.push({lvl:"warn", txt:"Curiosity question is empty."});
  if(!state.signal.loaded) msgs.push({lvl:"warn", txt:"No signal loaded."});

  obs.forEach(it=>{
    if(bannedInObserved(it.text)) msgs.push({lvl:"bad", txt:"Observed contains inference language."});
    if(it.because && it.because.trim()) msgs.push({lvl:"warn", txt:"Observed should not rely on because."});
    if(!it.evidence || !it.evidence.trim()) msgs.push({lvl:"warn", txt:"Observed missing evidence pointer."});
  });
  inf.forEach(it=>{
    if(!it.because || it.because.trim().length<3) msgs.push({lvl:"bad", txt:"Inferred missing because."});
    if(!it.contradiction || it.contradiction.trim().length<3) msgs.push({lvl:"warn", txt:"Add contradiction for an inferred claim."});
  });
  unk.forEach(it=>{
    if(!it.missing || it.missing.trim().length<3) msgs.push({lvl:"bad", txt:"Unknown missing missing signal."});
  });

  if(msgs.length===0) msgs.push({lvl:"good", txt:"All integrity checks passed."});

  $("checks").innerHTML = msgs.map(m=>{
    const box = m.lvl==="bad" ? "boxBad" : (m.lvl==="warn" ? "boxWarn" : "boxGood");
    const tag = m.lvl==="bad" ? "FAIL" : (m.lvl==="warn" ? "WARN" : "OK");
    return `<div class="${box}"><b>${tag}</b> ${esc(m.txt)}</div>`;
  }).join("<div style='height:8px'></div>");
}

$("runChecksBtn").addEventListener("click", ()=>{ runChecks(); renderAudit(); });

function renderAudit(){
  let score = 100;
  if(!$("caseName").value.trim()) score -= 10;
  if(!$("kidQ").value.trim()) score -= 10;
  if(!state.signal.loaded) score -= 8;

  const all = Object.values(state.panels).flat();
  all.forEach(it=>{
    if(it.kind==="Observed" && (!it.evidence||!it.evidence.trim())) score -= 3;
    if(it.kind==="Inferred" && (!it.because||it.because.trim().length<3)) score -= 6;
    if(it.kind==="Unknown" && (!it.missing||it.missing.trim().length<3)) score -= 6;
  });

  score = Math.max(0, Math.min(100, score));
  const grade = score>=90 ? "strong" : score>=75 ? "good" : score>=60 ? "weak" : "unsafe";

  const temp = state.temporal;
  const resLine = temp.samples.length
    ? `<div class="tiny"><b>Temporal</b> samples ${temp.samples.length} infoGain ${temp.infoGain.toFixed(4)} resistance ${temp.resistance.toFixed(2)}</div>`
    : `<div class="tiny muted">Temporal: not sampled</div>`;

  $("auditBox").innerHTML = `
    <div class="boxGood">
      <div class="tiny"><b>Integrity score</b>: ${score}/100 <b>grade</b>: ${grade}</div>
      ${resLine}
      <div class="tiny muted">Score measures structure completeness, not truth of the world.</div>
    </div>
  `;
}

$("calibrateBtn").addEventListener("click", ()=>{
  const note = prompt("Calibration log entry. What was wrong or learned?");
  if(!note) return;
  state.calibration.push({ at: nowIso(), note });
  $("calibration").innerHTML = state.calibration.slice(-6).reverse().map(x=>`
    <div class="item"><div class="tiny mono">${esc(x.at)}</div><div>${esc(x.note)}</div></div>
  `).join("");
  addAttempt("calibration", "entry added", true, {});
});

$("snapBtn").addEventListener("click", ()=>{
  if(!state.signal.loaded) return;
  const id = crypto.randomUUID();
  const name = (state.signal.source || "signal") + " " + new Date().toLocaleTimeString();
  const dataUrl = state.signal.dataUrl;

  if(!dataUrl){
    workCanvas.width = state.signal.w;
    workCanvas.height = state.signal.h;
    wctx.drawImage(img,0,0);
    state.signal.dataUrl = workCanvas.toDataURL("image/png");
  }

  state.memory.signals.push({ id, name, at: nowIso(), dataUrl: state.signal.dataUrl });
  updateMemorySelectors();
  addAttempt("memory", "signal saved: " + name, true, {});
});

$("loadA").addEventListener("click", ()=> loadSignalById($("sigA").value));
$("loadB").addEventListener("click", ()=> loadSignalById($("sigB").value));

$("clearAttemptsBtn").addEventListener("click", ()=>{
  state.attempts = [];
  renderAttempts();
});

$("exportBtn").addEventListener("click", ()=>{
  const obj = {
    meta: {
      caseName: $("caseName").value.trim(),
      scope: $("scopeTag").value,
      curiosity: $("kidQ").value.trim(),
      quality: $("sigNotes").value.trim(),
      assumptionsGlobal: $("assumptionsGlobal").value.trim(),
      constraintsGlobal: $("constraintsGlobal").value.trim()
    },
    modalities: state.modalities,
    attempts: state.attempts,
    signal: state.signal,
    panels: state.panels,
    anchors: state.anchors,
    calibration: state.calibration,
    memory: { signals: state.memory.signals.map(s => ({ id:s.id, name:s.name, at:s.at })) }
  };
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = (obj.meta.caseName ? obj.meta.caseName.replaceAll(" ","_") : "truth_engine_case") + ".json";
  a.click();
  addAttempt("export", "json exported", true, {});
});

$("importBtn").addEventListener("click", ()=>{
  const inp = document.createElement("input");
  inp.type = "file";
  inp.accept = "application/json";
  inp.onchange = () => {
    const f = inp.files && inp.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const obj = JSON.parse(reader.result);
        if(!obj || !obj.panels) throw new Error("Invalid file");

        $("caseName").value = obj.meta?.caseName || "";
        $("scopeTag").value = obj.meta?.scope || "personal";
        $("kidQ").value = obj.meta?.curiosity || "";
        $("sigNotes").value = obj.meta?.quality || "";
        $("assumptionsGlobal").value = obj.meta?.assumptionsGlobal || "";
        $("constraintsGlobal").value = obj.meta?.constraintsGlobal || "";

        state.panels = obj.panels || state.panels;
        state.anchors = obj.anchors || {};
        state.calibration = obj.calibration || [];
        state.attempts = obj.attempts || [];
        state.modalities = obj.modalities || state.modalities;

        $("reqDepth").checked = !!state.modalities.requested.depth;
        $("reqIR").checked = !!state.modalities.requested.ir;
        $("reqPol").checked = !!state.modalities.requested.pol;
        $("reqActive").checked = !!state.modalities.requested.active;
        renderModalities();

        state.signal.loaded = false;
        state.signal.source = "none";
        state.signal.timestamp = obj.signal?.timestamp || null;
        state.signal.dataUrl = null;

        enableSignalUI(false);
        setSigTime();
        renderPanels();
        renderAll();
        runChecks();
        renderAudit();
        renderAttempts();

        addAttempt("import", "json imported", true, {});
      }catch(err){
        alert("Import failed: " + err.message);
        addAttempt("import", "failed: " + err.message, false, {});
      }
    };
    reader.readAsText(f);
  };
  inp.click();
});

$("resetBtn").addEventListener("click", ()=>{
  stopTemporal();
  stopLiveCamera();

  state.signal = { loaded:false, w:0, h:0, timestamp:null, source:"none", id:null, dataUrl:null };
  state.panels = { Observed:[], Inferred:[], Unknown:[], Path:[] };
  state.drafts = [];
  state.calibration = [];
  state.selection = null;
  state.anchors = {};
  state.attempts = [];
  state.temporal = { running:false, timer:null, samples:[], last:null, infoGain:0, resistance:0 };
  state.memory = { signals:[] };
  state.modalities = {
    requested: { depth:false, ir:false, pol:false, active:false },
    probed: false,
    available: { depth:false, ir:false, pol:false, active:false, camera:false, torch:false },
    notes: []
  };

  $("caseName").value=""; $("kidQ").value=""; $("sigNotes").value="";
  $("assumptionsGlobal").value=""; $("constraintsGlobal").value="";
  $("reqDepth").checked=false; $("reqIR").checked=false; $("reqPol").checked=false; $("reqActive").checked=false;

  $("checks").innerHTML=""; $("calibration").innerHTML=""; $("draftsBox").innerHTML="";
  $("attemptBox").innerHTML=""; $("modBox").innerHTML=""; $("tempBox").innerHTML="";
  $("modStatus").textContent = "not probed";

  enableSignalUI(false);
  setSigTime();
  renderAll();
  renderPanels();
  renderAudit();
  updateMemorySelectors();
  renderAttempts();
  updateSecureUI();
  addAttempt("reset", "system reset", true, {});
});

function stopTemporal(){
  if(state.temporal.timer) clearInterval(state.temporal.timer);
  state.temporal.timer = null;
  state.temporal.running = false;
  $("tempStartBtn").disabled = !state.cam.active;
  $("tempStopBtn").disabled = true;
  $("tempCommitBtn").disabled = true;
}

function temporalStatFromVideo(){
  if(!state.cam.active || !camView.videoWidth) return null;

  camGrabCanvas.width = camView.videoWidth;
  camGrabCanvas.height = camView.videoHeight;
  gctx.drawImage(camView, 0, 0);

  const rect = state.selection || { x:0, y:0, w: camGrabCanvas.width, h: camGrabCanvas.height };

  let rx = 0, ry = 0, rw = camGrabCanvas.width, rh = camGrabCanvas.height;
  if(state.selection && state.signal.loaded){
    const sx = rect.x / state.signal.w;
    const sy = rect.y / state.signal.h;
    const sw = rect.w / state.signal.w;
    const sh = rect.h / state.signal.h;
    rx = Math.floor(sx * camGrabCanvas.width);
    ry = Math.floor(sy * camGrabCanvas.height);
    rw = Math.max(1, Math.floor(sw * camGrabCanvas.width));
    rh = Math.max(1, Math.floor(sh * camGrabCanvas.height));
  }

  const id = gctx.getImageData(rx, ry, rw, rh);
  const d = id.data;

  let sum=0,sum2=0;
  for(let i=0;i<d.length;i+=4){
    const L = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
    sum += L;
    sum2 += L*L;
  }
  const n = d.length/4;
  const mean = sum/n;
  const variance = Math.max(0,(sum2/n) - mean*mean);
  const std = Math.sqrt(variance);

  return { at: nowIso(), mean, std, rx, ry, rw, rh };
}

function updateTemporal(){
  const t = state.temporal;
  const s = temporalStatFromVideo();
  if(!s) return;

  t.samples.push(s);
  if(t.samples.length > 18) t.samples.shift();

  if(t.last){
    const dm = Math.abs(s.mean - t.last.mean);
    const ds = Math.abs(s.std - t.last.std);
    const delta = dm + ds;

    t.infoGain = 0.85 * t.infoGain + 0.15 * delta;

    const attempts = t.samples.length;
    const gain = Math.max(0.0001, t.infoGain);
    t.resistance = attempts / gain;

    let msg = "";
    if(delta < 0.6){
      msg = "Invariance detected. Region resisted change under current motion and time.";
    }else{
      msg = "Variation detected. Region is responding across time.";
    }

    $("tempBox").innerHTML = `
      <div class="boxGood">
        <div class="tiny"><b>Temporal</b> samples ${t.samples.length}</div>
        <div class="tiny"><b>infoGain</b> ${t.infoGain.toFixed(4)} <b>resistance</b> ${t.resistance.toFixed(2)}</div>
        <div class="tiny">${esc(msg)}</div>
        <div class="tiny muted">This measures change. It does not claim hidden content.</div>
      </div>
    `;

    $("tempCommitBtn").disabled = false;
  }

  t.last = s;
  renderAudit();
}

function startTemporal(){
  if(!state.cam.active) return;
  state.temporal.running = true;
  state.temporal.samples = [];
  state.temporal.last = null;
  state.temporal.infoGain = 0;
  state.temporal.resistance = 0;

  $("tempStartBtn").disabled = true;
  $("tempStopBtn").disabled = false;
  $("tempCommitBtn").disabled = true;

  state.temporal.timer = setInterval(updateTemporal, 700);
  addAttempt("temporal", "sampling started", true, {});
}

function stopTemporalSampling(){
  if(state.temporal.timer) clearInterval(state.temporal.timer);
  state.temporal.timer = null;
  state.temporal.running = false;

  $("tempStartBtn").disabled = !state.cam.active;
  $("tempStopBtn").disabled = true;
  $("tempCommitBtn").disabled = state.temporal.samples.length === 0;

  addAttempt("temporal", "sampling stopped", true, { samples: state.temporal.samples.length, infoGain: state.temporal.infoGain, resistance: state.temporal.resistance });
}

$("tempStartBtn").addEventListener("click", startTemporal);
$("tempStopBtn").addEventListener("click", stopTemporalSampling);

$("tempCommitBtn").addEventListener("click", ()=>{
  const t = state.temporal;
  if(t.samples.length < 2) return alert("Not enough temporal samples.");

  const kind = "Observed";
  const text = `Temporal evidence: region mean and std were sampled over time. infoGain ${t.infoGain.toFixed(4)} resistance ${t.resistance.toFixed(2)}.`;
  const evidence = `temporal samples ${t.samples.length}, latest mean ${t.last.mean.toFixed(1)}, latest std ${t.last.std.toFixed(1)}`;

  const claimId = crypto.randomUUID();
  state.panels[kind].push({
    id: claimId,
    kind,
    text,
    evidence,
    because:"",
    missing:"",
    contradiction:"If camera exposure or lighting changed abruptly without motion, temporal stats may be confounded.",
    assumptions:"Temporal stats reflect scene change under current sensing conditions.",
    confidence:0.70,
    risk:"low",
    source:"temporal",
    at: nowIso()
  });

  if(t.resistance > 40 && t.infoGain < 0.3){
    const uid = crypto.randomUUID();
    state.panels.Unknown.push({
      id: uid,
      kind:"Unknown",
      text:"Temporal sampling indicates strong invariance or occlusion. Hidden details may be unavailable under current modalities.",
      evidence:`resistance ${t.resistance.toFixed(2)} infoGain ${t.infoGain.toFixed(4)}`,
      because:"",
      missing:"A new viewpoint, moving occluder, or a different sensing modality not currently available.",
      contradiction:"If a new signal reveals new structure, this Unknown can be revised.",
      assumptions:"Invariance implies low information gain under current sensing.",
      confidence:0.85,
      risk:"low",
      source:"temporal",
      at: nowIso()
    });
  }

  renderPanels();
  runChecks();
  renderAudit();
  addAttempt("temporal", "evidence committed to panels", true, { resistance: t.resistance, infoGain: t.infoGain });
});

function renderModalitiesIfNeeded(){
  if(state.modalities.probed) renderModalities();
}

$("deltaToggle").addEventListener("change", ()=> renderAll());

function runInit(){
  enableSignalUI(false);
  setSigTime();
  renderAll();
  renderPanels();
  renderAudit();
  renderAttempts();
  updateMemorySelectors();
  renderModalitiesIfNeeded();
  updateSecureUI();
}
runInit();
})();
</script>

</body>
</html>
